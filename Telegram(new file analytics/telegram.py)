import os
import asyncio
from typing import Optional
import logging

try:
    from telegram import Bot
    from telegram.error import TelegramError
except ImportError:
    Bot = None
    TelegramError = None

# Config â€“ Render env vars (add these in dashboard)
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")

# Lazy bot init â€“ resilient even if creds missing
_bot: Optional[Bot] = None

logger = logging.getLogger(__name__)

def _get_bot() -> Optional[Bot]:
    global _bot
    if _bot is None and Bot and TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID:
        try:
            _bot = Bot(token=TELEGRAM_BOT_TOKEN)
            logger.info("Telegram bot initialized â€“ alerts armed")
        except Exception as e:
            logger.warning(f"Telegram bot init failed: {e}")
            _bot = None
    return _bot

async def send_alert(message: str) -> bool:
    """
    Send alert to Telegram chat. Returns True if successful.
    """
    bot = _get_bot()
    if not bot:
        logger.debug("Telegram alert skipped: bot not available")
        return False
    
    try:
        await bot.send_message(chat_id=TELEGRAM_CHAT_ID, text=message, parse_mode="HTML")
        logger.info(f"Telegram alert sent: {message[:50]}...")
        return True
    except TelegramError as e:
        logger.error(f"Telegram send failed: {e}")
        return False
    except Exception as e:
        logger.error(f"Unexpected Telegram error: {e}")
        return False

async def send_startup_alert(message: str = "ðŸ¤– AI Crypto Oracle Awakened\nAutonomous Swarm Active â€¢ Empire Compounding ðŸ”¥") -> bool:
    """
    Special startup broadcast â€“ loud and proud.
    """
    return await send_alert(f"<b>{message}</b>")

# Sync wrappers for optional sync calls (rare)
def send_alert_sync(message: str):
    if asyncio.get_event_loop().is_running():
        asyncio.create_task(send_alert(message))
    else:
        asyncio.run(send_alert(message))

def send_startup_alert_sync(message: str = "ðŸ¤– AI Crypto Oracle Awakened\nAutonomous Swarm Active â€¢ Empire Compounding ðŸ”¥"):
    asyncio.create_task(send_startup_alert(message))

"""Enhanced Telegram Alert Module - Production Ready"""

import asyncio
import logging
from typing import Optional, Union
from functools import partial

from telegram import Bot, ParseMode
from telegram.error import TelegramError, TimedOut, NetworkError, BadRequest
from telegram.ext import ApplicationBuilder

# Assuming config.py contains TELEGRAM_TOKEN and TELEGRAM_CHAT_ID
from config import Config

logger = logging.getLogger(__name__)

# Global async bot instance (lazy initialized)
_bot: Optional[Bot] = None
_bot_lock = asyncio.Lock()


async def _get_bot() -> Bot:
    """Lazy singleton for async Bot instance"""
    global _bot
    async with _bot_lock:
        if _bot is None:
            if not Config.TELEGRAM_TOKEN:
                raise ValueError("TELEGRAM_TOKEN not configured")
            _bot = Bot(token=Config.TELEGRAM_TOKEN)
            # Test token validity on first use
            try:
                await _bot.initialize()
            except Exception as e:
                logger.error(f"Invalid Telegram token: {e}")
                raise
        return _bot


async def send_alert_async(
    message: str,
    chat_id: Optional[Union[str, int]] = None,
    parse_mode: str = ParseMode.MARKDOWN_V2,
    disable_notification: bool = False,
    retry_attempts: int = 3,
    retry_delay: float = 2.0
) -> bool:
    """
    Send Telegram alert with retries and full error handling (async).

    Returns True if message was successfully sent.
    """
    target_chat_id = chat_id or Config.TELEGRAM_CHAT_ID
    if not target_chat_id:
        logger.error("TELEGRAM_CHAT_ID not configured and no override provided")
        return False

    # Escape MarkdownV2 special characters if needed
    if parse_mode == ParseMode.MARKDOWN_V2:
        # Basic escape for common problematic chars
        escaped = (
            message.replace('\\', '\\\\')
            .replace('_', '\\_').replace('*', '\\*').replace('`', '\\`')
            .replace('[', '\\[').replace(']', '\\]').replace('(', '\\(')
            .replace(')', '\\)').replace('~', '\\~').replace('>', '\\>')
            .replace('#', '\\#').replace('+', '\\+').replace('-', '\\-')
            .replace('=', '\\=').replace('|', '\\|').replace('{', '\\{')
            .replace('}', '\\}').replace('.', '\\.').replace('!', '\\!')
        )
    else:
        escaped = message

    bot = await _get_bot()

    for attempt in range(1, retry_attempts + 1):
        try:
            await bot.send_message(
                chat_id=target_chat_id,
                text=escaped[:4096],  # Enforce Telegram limit
                parse_mode=parse_mode,
                disable_notification=disable_notification,
                disable_web_page_preview=True
            )
            logger.info(f"Telegram alert sent successfully (attempt {attempt})")
            return True

        except (TimedOut, NetworkError) as e:
            logger.warning(f"Telegram timeout/network error (attempt {attempt}/{retry_attempts}): {e}")
            if attempt < retry_attempts:
                await asyncio.sleep(retry_delay * (2 ** (attempt - 1)))  # Exponential backoff
            continue

        except BadRequest as e:
            logger.error(f"Bad request to Telegram (likely bad formatting or blocked): {e}")
            # Try fallback to plain text
            if parse_mode != ParseMode.HTML:
                logger.info("Retrying with plain text")
                return await send_alert_async(
                    message=message,
                    chat_id=chat_id,
                    parse_mode=None,
                    retry_attempts=1
                )
            return False

        except TelegramError as e:
            logger.error(f"Telegram error: {e}")
            return False

    logger.error(f"Failed to send Telegram alert after {retry_attempts} attempts")
    return False


def send_alert(message: str, **kwargs) -> bool:
    """
    Synchronous wrapper for backward compatibility.
    Use only in non-async contexts (scripts, sync threads).
    """
    try:
        loop = asyncio.get_event_loop()
    except RuntimeError:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)

    if loop.is_running():
        # In running loop â†’ create task (non-blocking for caller)
        asyncio.create_task(send_alert_async(message, **kwargs))
        return True
    else:
        # Blocking call
        return loop.run_until_complete(send_alert_async(message, **kwargs))


# Optional: Rich alert helpers
async def send_alert_with_chart(message: str, photo_path: str, **kwargs):
    """Send message with attached image (e.g., equity curve)"""
    bot = await _get_bot()
    try:
        with open(photo_path, 'rb') as photo:
            await bot.send_photo(
                chat_id=Config.TELEGRAM_CHAT_ID,
                photo=photo,
                caption=message[:1024],
                parse_mode=ParseMode.MARKDOWN_V2
            )
        logger.info("Telegram alert with chart sent")
    except Exception as e:
        logger.error(f"Failed to send chart: {e}")
        await send_alert_async(f"Chart send failed: {e}\nOriginal: {message}")
