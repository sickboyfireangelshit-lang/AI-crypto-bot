"""Enhanced Telegram Alert Module - Production Ready"""

import asyncio
import logging
from typing import Optional, Union
from functools import partial

from telegram import Bot, ParseMode
from telegram.error import TelegramError, TimedOut, NetworkError, BadRequest
from telegram.ext import ApplicationBuilder

# Assuming config.py contains TELEGRAM_TOKEN and TELEGRAM_CHAT_ID
from config import Config

logger = logging.getLogger(__name__)

# Global async bot instance (lazy initialized)
_bot: Optional[Bot] = None
_bot_lock = asyncio.Lock()


async def _get_bot() -> Bot:
    """Lazy singleton for async Bot instance"""
    global _bot
    async with _bot_lock:
        if _bot is None:
            if not Config.TELEGRAM_TOKEN:
                raise ValueError("TELEGRAM_TOKEN not configured")
            _bot = Bot(token=Config.TELEGRAM_TOKEN)
            # Test token validity on first use
            try:
                await _bot.initialize()
            except Exception as e:
                logger.error(f"Invalid Telegram token: {e}")
                raise
        return _bot


async def send_alert_async(
    message: str,
    chat_id: Optional[Union[str, int]] = None,
    parse_mode: str = ParseMode.MARKDOWN_V2,
    disable_notification: bool = False,
    retry_attempts: int = 3,
    retry_delay: float = 2.0
) -> bool:
    """
    Send Telegram alert with retries and full error handling (async).

    Returns True if message was successfully sent.
    """
    target_chat_id = chat_id or Config.TELEGRAM_CHAT_ID
    if not target_chat_id:
        logger.error("TELEGRAM_CHAT_ID not configured and no override provided")
        return False

    # Escape MarkdownV2 special characters if needed
    if parse_mode == ParseMode.MARKDOWN_V2:
        # Basic escape for common problematic chars
        escaped = (
            message.replace('\\', '\\\\')
            .replace('_', '\\_').replace('*', '\\*').replace('`', '\\`')
            .replace('[', '\\[').replace(']', '\\]').replace('(', '\\(')
            .replace(')', '\\)').replace('~', '\\~').replace('>', '\\>')
            .replace('#', '\\#').replace('+', '\\+').replace('-', '\\-')
            .replace('=', '\\=').replace('|', '\\|').replace('{', '\\{')
            .replace('}', '\\}').replace('.', '\\.').replace('!', '\\!')
        )
    else:
        escaped = message

    bot = await _get_bot()

    for attempt in range(1, retry_attempts + 1):
        try:
            await bot.send_message(
                chat_id=target_chat_id,
                text=escaped[:4096],  # Enforce Telegram limit
                parse_mode=parse_mode,
                disable_notification=disable_notification,
                disable_web_page_preview=True
            )
            logger.info(f"Telegram alert sent successfully (attempt {attempt})")
            return True

        except (TimedOut, NetworkError) as e:
            logger.warning(f"Telegram timeout/network error (attempt {attempt}/{retry_attempts}): {e}")
            if attempt < retry_attempts:
                await asyncio.sleep(retry_delay * (2 ** (attempt - 1)))  # Exponential backoff
            continue

        except BadRequest as e:
            logger.error(f"Bad request to Telegram (likely bad formatting or blocked): {e}")
            # Try fallback to plain text
            if parse_mode != ParseMode.HTML:
                logger.info("Retrying with plain text")
                return await send_alert_async(
                    message=message,
                    chat_id=chat_id,
                    parse_mode=None,
                    retry_attempts=1
                )
            return False

        except TelegramError as e:
            logger.error(f"Telegram error: {e}")
            return False

    logger.error(f"Failed to send Telegram alert after {retry_attempts} attempts")
    return False


def send_alert(message: str, **kwargs) -> bool:
    """
    Synchronous wrapper for backward compatibility.
    Use only in non-async contexts (scripts, sync threads).
    """
    try:
        loop = asyncio.get_event_loop()
    except RuntimeError:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)

    if loop.is_running():
        # In running loop â†’ create task (non-blocking for caller)
        asyncio.create_task(send_alert_async(message, **kwargs))
        return True
    else:
        # Blocking call
        return loop.run_until_complete(send_alert_async(message, **kwargs))


# Optional: Rich alert helpers
async def send_alert_with_chart(message: str, photo_path: str, **kwargs):
    """Send message with attached image (e.g., equity curve)"""
    bot = await _get_bot()
    try:
        with open(photo_path, 'rb') as photo:
            await bot.send_photo(
                chat_id=Config.TELEGRAM_CHAT_ID,
                photo=photo,
                caption=message[:1024],
                parse_mode=ParseMode.MARKDOWN_V2
            )
        logger.info("Telegram alert with chart sent")
    except Exception as e:
        logger.error(f"Failed to send chart: {e}")
        await send_alert_async(f"Chart send failed: {e}\nOriginal: {message}")