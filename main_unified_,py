"""
AI Crypto Oracle - Autonomous Trading Bot
FastAPI-based system with ML predictions, portfolio management, and flash loan protection
"""
import os
import secrets
import inspect
from datetime import datetime
from typing import Any
from dotenv import load_dotenv

load_dotenv()

from fastapi import FastAPI, Request, Depends, HTTPException, BackgroundTasks
from fastapi.responses import HTMLResponse, JSONResponse
import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import ccxt.async_support as ccxt
import asyncio
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# ============================================================================
# SAFE IMPORTS - Never crash the oracle
# ============================================================================

def _safe_import():
    """Import modules safely with fallbacks"""
    send_alert = None
    send_startup_alert = None
    get_ml_signal = None
    Portfolio = None
    analytics_logger = None
    FlashLoanProtector = None
    
    try:
        from utils.telegram_alerts import send_alert as _sa, send_startup_alert as _ssa
        send_alert, send_startup_alert = _sa, _ssa
        logger.info("‚úì Telegram alerts loaded")
    except Exception as e:
        logger.warning(f"[WARN] Telegram alerts not available: {e}")
    
    try:
        from core.ml_predictor import get_ml_signal as _gms
        get_ml_signal = _gms
        logger.info("‚úì ML predictor loaded")
    except Exception as e:
        logger.warning(f"[WARN] ML predictor not available: {e}")
    
    try:
        from core.portfolio import Portfolio as _P
        Portfolio = _P
        logger.info("‚úì Portfolio module loaded")
    except Exception as e:
        logger.warning(f"[WARN] Portfolio module not available: {e}")
    
    try:
        from analytics.logger import analytics_logger as _al
        analytics_logger = _al
        logger.info("‚úì Analytics logger loaded")
    except Exception as e:
        logger.warning(f"[WARN] analytics.logger not available: {e}")
    
    try:
        from security.flash_loan_protection import FlashLoanProtector as _FLP
        FlashLoanProtector = _FLP
        logger.info("‚úì Flash loan protection loaded")
    except Exception as e:
        logger.warning(f"[WARN] Flash loan protection not available: {e}")
    
    return send_alert, send_startup_alert, get_ml_signal, Portfolio, analytics_logger, FlashLoanProtector

send_alert, send_startup_alert, get_ml_signal, Portfolio, analytics_logger, FlashLoanProtector = _safe_import()

# Create dummy logger if analytics not available
if analytics_logger is None:
    class DummyLogger:
        def log_event(self, *args, **kwargs): pass
        def log_trade(self, *args, **kwargs): pass
        def log_signal(self, *args, **kwargs): pass
        def log_error(self, *args, **kwargs): pass
    analytics_logger = DummyLogger()

def _log(msg: str):
    """Unified logging function"""
    try:
        logger.info(msg)
    except Exception:
        print(msg)

async def _maybe_await(fn, *args, **kwargs):
    """Helper to call sync or async functions"""
    if not fn:
        return None
    res = fn(*args, **kwargs)
    if inspect.isawaitable(res):
        return await res
    return res

# ============================================================================
# AUTH SYSTEM - Render Free friendly
# ============================================================================

def _valid_keys() -> set[str]:
    """Get valid API keys from environment"""
    raw = os.getenv("VALID_API_KEYS", "")
    return {k.strip() for k in raw.split(",") if k.strip()}

def require_api_key(request: Request):
    """Require valid API key in headers"""
    key = request.headers.get("X-API-Key", "")
    if key not in _valid_keys():
        raise HTTPException(status_code=401, detail="Invalid or missing API key")

def require_admin(request: Request):
    """Require admin secret in headers"""
    admin_secret = os.getenv("ADMIN_SECRET", "")
    provided = request.headers.get("X-Admin-Secret", "")
    if not admin_secret or provided != admin_secret:
        raise HTTPException(status_code=403, detail="Admin access denied")

def generate_api_key(prefix: str = "sk_live_") -> str:
    """Generate a new API key"""
    return prefix + secrets.token_hex(24)

# ============================================================================
# EXCHANGE SETUP
# ============================================================================

# Initialize exchange (BinanceUS with proper config)
exchange_config = {
    'apiKey': os.getenv('BINANCEUS_API_KEY', ''),
    'secret': os.getenv('BINANCEUS_SECRET', ''),
    'enableRateLimit': True,
    'options': {
        'defaultType': 'spot',
    },
}

exchange = ccxt.binanceus(exchange_config)

# Initialize portfolio if available
portfolio = Portfolio() if Portfolio else None

# Initialize flash loan protector if available
flash_loan_protector = FlashLoanProtector() if FlashLoanProtector else None

# ============================================================================
# FASTAPI APP - The Oracle Awakens
# ============================================================================

app = FastAPI(
    title="AI Crypto Oracle ‚Äì Autonomous Swarm 2025 üî•",
    version="1.1.0",
    description="Autonomous trading bot with ML predictions and flash loan protection"
)

# ============================================================================
# STARTUP & SHUTDOWN
# ============================================================================

@app.on_event("startup")
async def startup_event():
    """Initialize the trading bot on startup"""
    logger.info("=" * 60)
    logger.info("üîÆ Oracle Trading Bot Starting...")
    logger.info("=" * 60)
    
    # Log module availability
    logger.info(f"Telegram Alerts: {'‚úì' if send_alert else '‚úó'}")
    logger.info(f"ML Predictor: {'‚úì' if get_ml_signal else '‚úó'}")
    logger.info(f"Analytics: {'‚úì' if analytics_logger else '‚úó'}")
    logger.info(f"Portfolio: {'‚úì' if portfolio else '‚úó'}")
    logger.info(f"Flash Loan Protection: {'‚úì' if flash_loan_protector else '‚úó'}")
    
    logger.info("=" * 60)
    logger.info("üöÄ Oracle awakened ‚Äì startup complete")
    logger.info("=" * 60)
    
    # Send startup alert if available
    await _maybe_await(send_startup_alert)
    
    # Start background trading swarm
    asyncio.create_task(background_trading_swarm())

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    """Handle all uncaught exceptions"""
    _log(f"Uncaught exception: {exc}")
    await _maybe_await(send_alert, f"‚ö†Ô∏è Oracle Resilience Activated\nError: {exc}\nEmpire continues")
    return JSONResponse(
        status_code=500,
        content={"detail": "Oracle resilient ‚Äì empire endures üî•", "error": str(exc)}
    )

# ============================================================================
# HEALTH CHECK ENDPOINTS - FIXED FOR FASTAPI
# ============================================================================

@app.get("/")
async def root():
    """Root endpoint with HTML dashboard"""
    return HTMLResponse("""
    <html>
        <head><title>AI Crypto Oracle 2025</title></head>
        <body style="background:#000;color:#0f0;font-family:monospace;text-align:center;padding:100px;">
            <h1>ü§ñ AI CRYPTO ORACLE ‚Äì LIVE & RESILIENT</h1>
            <h2>Autonomous Swarm Active ‚Ä¢ Predicting ‚Ä¢ Trading ‚Ä¢ Conquering</h2>
            <p>
                <a href="/docs" style="color:#0f0;">Interactive Docs</a> ‚Ä¢
                <a href="/redoc" style="color:#0f0;">ReDoc</a> ‚Ä¢
                <a href="/health" style="color:#0f0;">Health</a> ‚Ä¢
                <a href="/status" style="color:#0f0;">Status</a>
            </p>
            <p>The empire self-heals and compounds eternal üî•</p>
        </body>
    </html>
    """)

@app.head("/")
async def root_head():
    """HEAD request for root endpoint"""
    return {}

@app.get("/health")
async def health():
    """Health check with exchange balance"""
    try:
        balance = await exchange.fetch_balance()
        return {
            "status": "Oracle Alive & Resilient",
            "timestamp": datetime.utcnow().isoformat(),
            "balance": balance.get("total", {})
        }
    except Exception as e:
        _log(f"Health check failed: {e}")
        await _maybe_await(send_alert, f"‚ö†Ô∏è Health error: {e}")
        return {
            "status": "Resilient ‚Äì recovering",
            "error": str(e),
            "timestamp": datetime.utcnow().isoformat()
        }

# ============================================================================
# API ENDPOINTS
# ============================================================================

@app.get("/status", dependencies=[Depends(require_api_key)])
async def status():
    """Get detailed system status"""
    try:
        balance = await exchange.fetch_balance()
        return {
            "oracle": "LIVE & RESILIENT",
            "timestamp": datetime.utcnow().isoformat(),
            "balance_total": balance.get("total", {}),
            "portfolio": portfolio.get_summary() if portfolio else {"warning": "portfolio not loaded"},
            "modules": {
                "telegram": bool(send_alert),
                "ml_predictor": bool(get_ml_signal),
                "analytics": bool(analytics_logger),
                "portfolio": bool(portfolio),
                "flash_loan_protection": bool(flash_loan_protector)
            }
        }
    except Exception as e:
        logger.error(f"Status error: {e}")
        return JSONResponse(
            status_code=500,
            content={"error": str(e)}
        )

@app.get("/signal", dependencies=[Depends(require_api_key)])
async def signal(symbol: str = "BTC/USDT"):
    """Get ML trading signal for a symbol"""
    if not get_ml_signal:
        raise HTTPException(status_code=503, detail="ML predictor unavailable")
    
    try:
        ohlcv = await exchange.fetch_ohlcv(symbol, "1h", limit=100)
        df = pd.DataFrame(ohlcv, columns=["timestamp", "open", "high", "low", "close", "volume"])
        prediction = get_ml_signal(df)
        
        # Log the signal
        analytics_logger.log_signal(symbol, "ml_prediction", 0.8)
        
        await _maybe_await(send_alert, f"üß† PROPHECY: {prediction.upper()} on {symbol}")
        return {
            "signal": prediction,
            "symbol": symbol,
            "timestamp": datetime.utcnow().isoformat()
        }
    except Exception as e:
        _log(f"Signal error: {e}")
        analytics_logger.log_error("signal_error", str(e))
        await _maybe_await(send_alert, f"‚ùå Signal failed: {e} ‚Üí fallback HOLD")
        return {
            "signal": "hold",
            "symbol": symbol,
            "error": str(e)
        }

@app.get("/portfolio", dependencies=[Depends(require_api_key)])
async def get_portfolio():
    """Get current portfolio status"""
    if not portfolio:
        raise HTTPException(status_code=503, detail="Portfolio unavailable")
    
    try:
        return {
            "portfolio": portfolio.get_summary(),
            "timestamp": datetime.utcnow().isoformat()
        }
    except Exception as e:
        logger.error(f"Portfolio error: {e}")
        return JSONResponse(
            status_code=500,
            content={"error": str(e)}
        )

@app.get("/trades", dependencies=[Depends(require_api_key)])
async def get_trades(limit: int = 10):
    """Get recent trades"""
    if not portfolio:
        raise HTTPException(status_code=503, detail="Portfolio unavailable")
    
    try:
        return {
            "trades": portfolio.get_recent_trades(limit),
            "timestamp": datetime.utcnow().isoformat()
        }
    except Exception as e:
        logger.error(f"Trades error: {e}")
        return JSONResponse(
            status_code=500,
            content={"error": str(e)}
        )

@app.get("/charts", response_class=HTMLResponse, dependencies=[Depends(require_api_key)])
async def profit_charts():
    """Generate profit visualization charts"""
    if not portfolio:
        raise HTTPException(status_code=503, detail="Portfolio unavailable")
    
    try:
        trades = portfolio.get_trades_df()
        if trades is None or len(trades) == 0:
            return HTMLResponse("<h2 style='font-family:monospace;color:#0f0;'>No trade data yet ‚Äì empire building</h2>")
        
        fig = make_subplots(rows=2, cols=1, subplot_titles=("Equity Curve", "Daily PnL"))
        fig.add_trace(go.Scatter(x=trades["date"], y=trades["equity"], name="Equity"), row=1, col=1)
        fig.add_trace(go.Bar(x=trades["date"], y=trades["pnl"], name="PnL"), row=2, col=1)
        fig.update_layout(template="plotly_dark", height=800, title_text="Profit Dashboard ‚Äì Empire Growth")
        return HTMLResponse(fig.to_html(full_html=False, include_plotlyjs="cdn"))
    except Exception as e:
        logger.error(f"Charts error: {e}")
        return HTMLResponse(f"<h2 style='color:red;'>Error generating charts: {e}</h2>")

@app.get("/analytics/events", dependencies=[Depends(require_api_key)])
async def get_events(event_type: str = None, limit: int = 100):
    """Get analytics events"""
    try:
        events = analytics_logger.get_events(event_type=event_type, limit=limit)
        return {
            "events": events,
            "count": len(events),
            "timestamp": datetime.utcnow().isoformat()
        }
    except Exception as e:
        logger.error(f"Events error: {e}")
        return JSONResponse(
            status_code=500,
            content={"error": str(e)}
        )

@app.get("/security/flash-loan-check", dependencies=[Depends(require_api_key)])
async def flash_loan_check(symbol: str = "BTC/USDT"):
    """Check for flash loan attacks"""
    if not flash_loan_protector:
        raise HTTPException(status_code=503, detail="Flash loan protection unavailable")
    
    try:
        is_safe = flash_loan_protector.check_market_manipulation(symbol)
        
        return {
            "symbol": symbol,
            "safe": is_safe,
            "timestamp": datetime.utcnow().isoformat()
        }
    except Exception as e:
        logger.error(f"Flash loan check error: {e}")
        return JSONResponse(
            status_code=500,
            content={"error": str(e)}
        )

# ============================================================================
# ADMIN ENDPOINTS
# ============================================================================

@app.post("/admin/generate-key", dependencies=[Depends(require_admin)])
async def admin_generate_key(request: Request):
    """Generate a new API key (admin only)"""
    try:
        body = await request.json()
        prefix = body.get("prefix", "sk_live_")
        new_key = generate_api_key(prefix)
        return {
            "api_key": new_key,
            "created_at": datetime.utcnow().isoformat()
        }
    except Exception as e:
        logger.error(f"Key generation error: {e}")
        return JSONResponse(
            status_code=500,
            content={"error": str(e)}
        )

# ============================================================================
# BACKGROUND TASKS
# ============================================================================

async def background_trading_swarm():
    """Autonomous trading loop - runs in background"""
    logger.info("ü§ñ Background trading swarm activated")
    
    while True:
        try:
            if get_ml_signal:
                # Get signal for BTC
                await signal(symbol="BTC/USDT")
            
            await asyncio.sleep(3600)  # Run every hour
            
        except Exception as e:
            _log(f"Swarm error: {e} ‚Äì self-healing")
            analytics_logger.log_error("swarm_error", str(e))
            await _maybe_await(send_alert, f"‚ö†Ô∏è Swarm error: {e} ‚Üí restarting")
            await asyncio.sleep(60)  # Wait before retry

# ============================================================================
# ERROR HANDLERS
# ============================================================================

@app.exception_handler(404)
async def not_found_handler(request: Request, exc):
    """Handle 404 errors"""
    return JSONResponse(
        status_code=404,
        content={
            "error": "Not Found",
            "path": str(request.url.path)
        }
    )

@app.exception_handler(500)
async def internal_error_handler(request: Request, exc):
    """Handle 500 errors"""
    logger.error(f"Internal error: {exc}")
    return JSONResponse(
        status_code=500,
        content={
            "error": "Internal Server Error",
            "message": str(exc)
        }
    )

# ============================================================================
# MAIN ENTRY POINT
# ============================================================================

if __name__ == "__main__":
    import uvicorn
    
    port = int(os.getenv("PORT", 8000))
    
    logger.info(f"Starting Oracle on port {port}")
    
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=port,
        log_level="info"
    ) 
